# 차이점 요약
1. HashMap (java.util.HashMap)
동기화(스레드 안전) 보장 X
여러 스레드가 동시에 put/get/modify 시 데이터 손상, 예외 발생 가능
단일 스레드 환경, 혹은 외부에서 별도 락(lock)으로 제어할 때만
 안전
2. ConcurrentHashMap (java.util.concurrent.ConcurrentHashMap)
동기화(스레드 안전) 보장 O
내부적으로 세그먼트/버킷 단위로 락을 걸어 동시 접근을 효율적으로 처리
멀티스레드 환경에서 안전하게 put/get/modify 가능
성능도 좋음 (전체 락이 아니라 부분 락)


1. HashMap
동기화(스레드 안전) 기능이 없음
여러 스레드가 동시에 put/get/수정하면 내부 데이터 구조(배열, 버킷 등)가 깨질 수 있음
예를 들어, 한 스레드가 데이터를 추가하는 중에 다른 스레드가 데이터를 읽거나 수정하면
데이터가 유실되거나, 무한 루프, ConcurrentModificationException 등이 발생할 수 있음
단일 스레드 환경이나, 외부에서 직접 락(lock)으로 제어할 때만 안전
2. ConcurrentHashMap
동기화(스레드 안전) 기능 내장
내부적으로 데이터를 여러 구역(버킷, 세그먼트)으로 나누고,
각 구역별로 락을 걸어 여러 스레드가 동시에 안전하게 접근할 수 있도록 설계됨
전체 맵에 락을 거는 것이 아니라, 부분적으로만 락을 걸기 때문에
동시성 + 성능을 모두 잡을 수 있음
put, get, remove 등 주요 연산이 모두 스레드 안전하게 동작
왜 이런 차이가 생기나?
HashMap은 원래 단일 스레드 환경(즉, 동시 접근이 없는 상황)에서 빠른 성능을 위해 설계됨
→ 락, 동기화 코드가 없으니 빠르지만, 멀티스레드 환경에서는 위험
ConcurrentHashMap은 멀티스레드 환경에서 안전하게 사용하기 위해
→ 내부적으로 락, CAS(Compare-And-Swap) 등 동기화 기법을 사용해 설계됨



구체적으로 어떻게 동작하나요?
1. HashMap
락이 없음(동기화 X)
여러 스레드가 동시에 접근하면 데이터가 깨질 수 있음
2. ConcurrentHashMap
JDK 8 이전:
내부적으로 여러 개의 세그먼트(segment)로 나누고,
각 세그먼트마다 별도의 락(뮤텍스)을 사용
여러 스레드가 서로 다른 세그먼트에 접근하면 동시에 작업 가능
JDK 8 이후:
세그먼트 구조 대신 버킷(노드) 단위로 락을 거는 방식으로 변경
CAS(Compare-And-Swap), synchronized, ReentrantLock 등 다양한 락/동기화 기법을 조합해서
성능과 안전성을 모두 잡음
세마포어와 뮤텍스의 차이
뮤텍스(Mutex): 한 번에 한 스레드만 접근 가능(단일 락)
세마포어(Semaphore): 여러 스레드가 동시에 접근 가능(카운팅 락, ex. 3명까지 입장 가능)
ConcurrentHashMap은 주로 뮤텍스(혹은 ReentrantLock)를 사용해서
각 구역(버킷/노드)별로 락을 걸어줍니다.



1. ReentrantLock이란?
java.util.concurrent.locks.ReentrantLock
자바에서 제공하는 명시적 락(Explicit Lock) 클래스
synchronized와 비슷하지만, 더 많은 기능(공정성, 조건 변수, tryLock 등)을 제공
Reentrant란 "재진입 가능"이라는 뜻으로,
같은 스레드가 이미 락을 획득한 상태에서 다시 락을 요청해도 블로킹되지 않고 바로 획득 가능



2. ConcurrentHashMap과의 관계
ConcurrentHashMap은 내부적으로 동시성 제어를 위해
ReentrantLock(또는 JDK 버전에 따라 synchronized, CAS 등)을 사용합니다.
즉, 개발자가 직접 락을 걸 필요 없이,
ConcurrentHashMap이 내부적으로 필요한 부분에 ReentrantLock을 사용해서
여러 스레드가 동시에 안전하게 데이터를 다룰 수 있도록 해줍니다.
직접 조합할 필요가 있을까?
일반적으로는 필요 없음!
대부분의 경우, ConcurrentHashMap만 사용하면 내부적으로 락이 잘 관리됨
특별한 경우(예: 여러 연산을 원자적으로 처리하고 싶을 때)
예를 들어, put → get → remove 등 여러 연산을 하나의 락으로 묶고 싶을 때
직접 ReentrantLock을 사용할 수 있음

# 통합테스트에서는 Autowired 쓰기 vs 직접 객체 사용하기
1. 직접 객체 생성 방식 (수동 DI)
테스트 코드에서 필요한 객체(Repository, Service 등)를 new로 직접 생성해서 사용
장점
테스트가 빠르고, Spring 컨텍스트를 띄우지 않아도 됨 (가볍고 빠름)
외부 환경(Spring 설정, DB 등)에 영향받지 않음 → 순수 자바 단위/통합 테스트에 적합
Mock, Stub, In-memory DB 등 원하는 대로 조합 가능
단점
실제 운영 환경(Spring DI, AOP, 트랜잭션 등)과 다를 수 있음
Bean 주입, 설정, AOP, 트랜잭션 등 Spring 기능이 필요한 경우에는 한계
2. @Autowired, @SpringBootTest 등 Spring DI 사용
Spring 컨텍스트를 띄우고, @Autowired로 Bean을 주입받아 테스트
장점
실제 운영 환경과 거의 동일하게 테스트 가능 (DI, 트랜잭션, AOP 등 모두 적용)
Spring의 각종 기능(트랜잭션 롤백, MockMvc, @Transactional 등) 활용 가능
단점
테스트 실행 속도가 느림 (컨텍스트 로딩)
환경설정, DB 등 외부 의존성이 많아질 수 있음
결론 및 추천
비즈니스 로직, 동시성, 메모리 기반 통합 테스트
→ 직접 객체 생성 방식이 빠르고, 독립적이며, 테스트가 쉽습니다.
(특히, DB 없이 메모리 Table을 쓴다면 더욱 적합)
실제 운영 환경과 동일한 조건, 트랜잭션, AOP, DB 연동 등까지 검증
→ @SpringBootTest + @Autowired 방식이 더 적합합니다.

---

# 꼭 Autowired를 안 써도 되는 경우
1. 메모리 기반(가짜) DB 사용
현재 구조는 실제 DB가 아니라,
UserPointTable, PointHistoryTable 등 메모리 기반의 Table을 사용합니다.
이런 경우 Spring의 DI 컨테이너를 굳이 띄우지 않아도
new로 직접 객체를 만들어도 테스트가 완전히 독립적이고,
외부 환경에 영향받지 않습니다.
2. 테스트 속도와 단순성
Spring 컨텍스트를 띄우면 테스트가 느려지고,
불필요한 설정/환경에 영향을 받을 수 있습니다.
직접 객체를 생성하면 테스트가 훨씬 빠르고, 코드가 단순해집니다.
3. 동시성/비즈니스 로직 검증에 집중
이 테스트의 목적은
동시성 제어, 비즈니스 로직의 정확성을 검증하는 것입니다.
Spring의 트랜잭션, AOP, DI 등 프레임워크 기능이 필요하지 않습니다.
4. 외부 의존성 최소화
Spring 환경(@Autowired, @SpringBootTest 등)을 사용하면
환경설정, DB, MockBean 등 외부 의존성이 늘어날 수 있습니다.
직접 객체 생성 방식은 테스트가 완전히 독립적이어서
어디서든, 어떤 환경에서도 동일하게 동작합니다.

---

# Service 생성자에 인자가 늘어났을 때의 문제점
InjectMocks를 안 사용하고 그냥 일반 생성자를 사용하니 인자가 늘어났을때 컴파일 에러가 나는 현생이 발생한다.

1. 생성자 인자 관리가 자동화됨
생성자에 인자가 많아지거나, 순서가 바뀌거나, 새로운 의존성이 추가되어도
@InjectMocks는 @Mock/@Spy로 선언된 객체를 자동으로 주입해줍니다.
직접 생성자를 호출하면 인자 순서, 개수, 타입을 항상 맞춰야 해서
생성자 변경 시 테스트 코드도 일일이 수정해야 합니다.
2. 테스트 코드의 가독성/유지보수성 향상
테스트 클래스 상단에 필드 선언만 하면 끝!
생성자 호출 코드가 없어져서 테스트 코드가 더 깔끔해집니다.
의존성 주입이 명확하게 드러나므로,
어떤 Mock이 실제로 주입되는지 한눈에 파악할 수 있습니다.
3. 생성자/필드/Setter 주입 모두 지원
@InjectMocks는 생성자뿐 아니라,
필드 주입, Setter 주입도 자동으로 지원합니다.
실제 코드가 어떤 방식으로 DI를 하든 테스트 코드는 동일하게 유지할 수 있습니다.
4. 테스트 코드의 견고함
서비스의 생성자에 새로운 의존성이 추가되어도
@Mock만 추가하면 테스트가 깨지지 않습니다.
직접 생성자 호출 방식은 인자 누락/순서 오류 등으로 테스트가 깨질 수 있습니다.
5. Mockito의 확장 기능과 연계
@InjectMocks와 @Mock을 함께 쓰면
Mockito의 다양한 기능(verify, when 등)과 자연스럽게 연동됩니다.

---

# 왜 일반 생성자가 비즈니스 로직, 동시성, 메모리 기반 Table 검증이 목적일때 더 유리한가
직접 객체 생성이 더 빠르고, 설정이 단순합니다.
의존성 주입, Mocking, Spring/Mockito 기능 활용이 필요하다면
@InjectMocks, @Mock을 사용하는 것이 더 적합합니다

1. 불필요한 프레임워크 의존성 제거
Spring, Mockito 등 외부 프레임워크 없이
순수 자바 코드만으로 테스트가 가능합니다.
테스트가 더 빠르고, 환경에 구애받지 않습니다.
2. 테스트 속도 향상
컨테이너를 띄우지 않으니 테스트 실행 속도가 매우 빠릅니다.
수백~수천 개의 테스트도 부담 없이 돌릴 수 있습니다.
3. 테스트의 독립성/단순성
객체 생성, 상태 초기화, 검증이 모두 명확하게 드러납니다.
Mock, Stub, Spy 등 복잡한 설정 없이
실제 구현체(메모리 Table 등)를 바로 사용할 수 있습니다.
4. 동시성/상태 검증에 유리
여러 스레드에서 직접 객체를 공유하며
동시성 문제, race condition 등을 명확하게 검증할 수 있습니다.
Mock은 내부 동작을 시뮬레이션할 뿐, 실제 동시성 이슈는 잡아내지 못합니다.
5. 실제 운영 코드와 거의 동일한 환경
실제 서비스에서 사용하는 객체 구조와 거의 동일하게 테스트가 가능합니다.
단, DB, 트랜잭션 등 외부 시스템 연동이 필요하다면 별도 통합 테스트가 필요합니다.

---
# InjectMocks를 사용해서 테스트 시 생기는 문제점
1. 테스트의 명시성/직관성 저하
@InjectMocks는 내부적으로 리플렉션(Reflection)과 자동 주입을 사용합니다.
실제로 어떤 생성자가 호출되는지, 어떤 Mock이 주입되는지 코드상에서 명확히 보이지 않습니다.
직접 생성자 호출은 어떤 객체가 어떤 인자로 생성되는지 한눈에 알 수 있습니다.
2. 생성자/필드/Setter 주입 혼용 시 혼란
@InjectMocks는 생성자, 필드, Setter 주입을 모두 지원하지만
실제 코드가 어떤 방식으로 DI를 하는지에 따라
예상과 다르게 주입될 수 있습니다.
실수로 Mock이 누락되거나, 잘못된 Mock이 주입될 위험이 있습니다.
3. 리팩토링 시 테스트 깨짐
생성자 인자, 필드, Setter 등이 변경되면
@InjectMocks가 제대로 주입하지 못해
NullPointerException 등 런타임 에러가 발생할 수 있습니다.
직접 생성자 호출은 컴파일 타임에 바로 에러를 확인할 수 있습니다.
4. 테스트 디버깅/문제 추적 어려움
Mock 주입이 자동으로 이뤄지기 때문에
어떤 Mock이 실제로 주입됐는지,
왜 NullPointerException이 발생했는지
디버깅이 어려울 수 있습니다.
5. 외부 프레임워크 의존성
Mockito, JUnit 확장 등 외부 프레임워크에 의존해야 하며,
설정(@ExtendWith 등)이 누락되면 제대로 동작하지 않습니다.
순수 자바 테스트에서는 불필요한 의존성이 추가됩니다.
6. 테스트 코드의 은닉성
테스트 코드가 간결해지는 대신,
실제 객체 생성/주입 과정이 숨겨져 있어
테스트의 동작 원리를 파악하기 어려울 수 있습니다.


---
# Mock 객체를 써야할 때와 실제 객체를 써야 할때
1. Mock 객체를 써야 하는 경우
① 외부 의존성(네트워크, DB, 파일 등)을 대체하고 싶을 때
DB, 외부 API, 파일 시스템 등 느리거나 불안정한 의존성을 테스트에서 대체하고 싶을 때
② 테스트 대상 클래스의 동작만 검증하고 싶을 때
Service의 비즈니스 로직만 검증하고, Repository/DAO 등은 실제 동작하지 않아도 될 때
③ 특정 상황(예외, 반환값 등)을 강제로 만들고 싶을 때
예외 상황, 경계값, 특정 조건 등을 쉽게 시뮬레이션하고 싶을 때
④ 테스트 속도를 빠르게 하고 싶을 때
실제 객체는 느릴 수 있으나, Mock은 매우 빠름
⑤ 부작용(데이터 변경, 외부 호출 등)을 방지하고 싶을 때
테스트 중 실제 데이터가 변경되거나, 외부 시스템에 영향을 주지 않게 하고 싶을 때
⑥ 아직 구현되지 않은 의존성을 대체하고 싶을 때
개발 중간 단계에서 하위 모듈이 완성되지 않았을 때
2. 실제 객체(실구현체)를 써야 하는 경우
① 통합 테스트, E2E 테스트 등 실제 동작을 검증하고 싶을 때
여러 컴포넌트가 실제로 잘 연동되는지, 전체 플로우가 정상 동작하는지 확인할 때
② 비즈니스 로직, 상태 변화, 동시성 등 실제 동작이 중요한 경우
Mock은 내부 동작을 시뮬레이션할 뿐, 실제 상태 변화나 동시성 이슈는 검증 불가
③ 외부 시스템과의 연동을 실제로 검증하고 싶을 때
실제 DB, 외부 API, 파일 등과의 연동이 잘 되는지 확인하고 싶을 때
④ Mocking이 오히려 복잡하거나, 의미가 없을 때
단순한 객체, 메모리 기반 Table 등은 굳이 Mock으로 대체할 필요 없음
⑤ 운영 환경과 최대한 유사한 조건에서 테스트하고 싶을 때
실제 객체를 써야 운영 환경과의 차이를 줄일 수 있음
정리 표
상황/목적	Mock 객체 사용	실제 객체 사용
외부 의존성 대체	O	X
비즈니스 로직만 검증	O	X
예외/특수 상황 시뮬레이션	O	X
테스트 속도 중요	O	△
부작용 방지	O	X
통합/플로우/상태/동시성 검증	X	O
실제 연동 검증	X	O
운영 환경과 유사한 테스트	X	O
단순 객체/메모리 Table	△	O
실무 팁
단위 테스트: Mock 객체 적극 활용 (Service, Controller 등)
통합/시스템 테스트: 실제 객체(실구현체) 사용



#  UserPointService 통합테스트 할때는 SpringBootTest 안 붙이다가 Controller 통합테스트에는 붙이는 이유

1. UserPointService 통합테스트 (SpringBootTest 없이 직접 객체 생성)
테스트 목적:
Service, Table, LockProvider 등 비즈니스 로직 계층의 동작과 동시성, 데이터 일관성 검증이 목적입니다.
구현 방식:
new UserPointService(...)처럼 직접 객체를 생성해서 테스트합니다.
이유:
Spring의 DI, 빈 등록, 웹 환경이 필요하지 않음
테스트가 빠르고, 불필요한 Spring 컨텍스트 로딩이 없음
메모리 기반 Table 등 가벼운 환경에서 순수 자바 객체로만 검증 가능
2. Controller 통합테스트 (SpringBootTest + MockMvc)
테스트 목적:
HTTP 요청/응답, 컨트롤러 계층, 실제 API 동작을 통합적으로 검증하는 것이 목적입니다.
구현 방식:
@SpringBootTest와 @AutoConfigureMockMvc를 사용해 Spring ApplicationContext 전체를 띄우고,
실제처럼 MockMvc로 HTTP 요청을 보냅니다.
이유:
Spring의 DI, 빈 등록, 웹 환경이 필요
실제 API 엔드포인트, 요청/응답, 시리얼라이즈/디시리얼라이즈, 예외처리 등 전체 플로우 검증
컨트롤러와 서비스, 레포지토리 등 여러 계층이 실제로 연결되어 동작하는지 확인
요약 표
테스트 대상	SpringBootTest 사용	목적/이유
Service 통합테스트	X	순수 자바 객체로 비즈니스 로직, 동시성 검증
Controller 통합테스트	O	실제 HTTP API, Spring 환경, 전체 플로우 검증
즉,
Service 테스트는 빠르고 가볍게, 순수 자바 객체로만 검증
Controller 테스트는 실제 API 환경과 최대한 유사하게, Spring 컨텍스트를 띄워서 검증