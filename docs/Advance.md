# HashMap vs ConcurrentHashMap 차이점 요약

## 1. HashMap과 ConcurrentHashMap의 동기화 및 동시성

| 구분                | HashMap                          | ConcurrentHashMap                   |
|---------------------|----------------------------------|-------------------------------------|
| 동기화(스레드 안전) | X                                | O                                   |
| 동시 접근           | 데이터 손상, 예외 발생 가능      | 안전하게 put/get/modify 가능        |
| 락 적용 방식        | 없음                             | 부분 락(버킷/노드 단위)             |
| 사용 환경           | 단일 스레드, 직접 락 필요        | 멀티스레드, 성능과 안전성 모두 우수 |

- **HashMap**은 동기화 기능이 없어 여러 스레드가 동시에 접근하면 데이터가 손상될 수 있습니다.
- **ConcurrentHashMap**은 내부적으로 세그먼트/버킷 단위로 락을 걸어 동시 접근을 효율적으로 처리합니다.

---

## 2. 동작 방식의 구체적 차이

- **HashMap**
  - 락이 전혀 없음.
  - 여러 스레드가 동시에 put/get/수정 시 데이터 유실, 무한 루프, 예외 발생 가능.
  - 단일 스레드 환경 또는 외부에서 직접 락을 걸 때만 안전.

- **ConcurrentHashMap**
  - JDK 8 이전: 세그먼트(segment) 단위로 락을 걸어 여러 스레드가 동시에 작업 가능.
  - JDK 8 이후: 버킷(노드) 단위로 락을 걸어 더 세밀하게 동시성 제어.
  - CAS(Compare-And-Swap), synchronized, ReentrantLock 등 다양한 동기화 기법을 조합해 성능과 안전성 모두 확보.

---

## 3. 동기화 관련 용어 정리

- **뮤텍스(Mutex)**: 한 번에 한 스레드만 접근 가능한 단일 락.
- **세마포어(Semaphore)**: 여러 스레드가 동시에 접근 가능한 카운팅 락.
- **ReentrantLock**: 자바에서 제공하는 명시적 락. 같은 스레드가 여러 번 락을 획득해도 블로킹되지 않음. ConcurrentHashMap 내부에서 부분 락 구현에 사용됨.

---

## 4. 통합테스트에서 DI 방식 선택 가이드

### 4.1. 직접 객체 생성 방식 (수동 DI)

- **장점**
  - 테스트가 빠르고 가벼움 (Spring 컨텍스트 불필요)
  - 외부 환경에 영향받지 않음
  - Mock, Stub, In-memory DB 등 자유롭게 조합 가능
- **단점**
  - Spring DI, AOP, 트랜잭션 등 실제 운영 환경과 다를 수 있음

### 4.2. @Autowired, @SpringBootTest 등 Spring DI 사용

- **장점**
  - 실제 운영 환경과 거의 동일하게 테스트 가능 (DI, 트랜잭션, AOP 등 모두 적용)
  - Spring의 다양한 기능 활용 가능
- **단점**
  - 테스트 실행 속도가 느림
  - 외부 의존성이 많아질 수 있음

#### 결론
- **비즈니스 로직, 동시성, 메모리 기반 통합 테스트**: 직접 객체 생성 방식이 빠르고 독립적
- **실제 운영 환경과 동일한 조건, 트랜잭션, DB 연동 등 검증**: @SpringBootTest + @Autowired 방식 권장

---

## 5. Autowired를 안 써도 되는 경우

1. **메모리 기반(가짜) DB 사용**: 직접 객체 생성으로 테스트가 완전히 독립적
2. **테스트 속도와 단순성**: Spring 컨텍스트 없이 빠르고 단순한 테스트 가능
3. **동시성/비즈니스 로직 검증에 집중**: 프레임워크 기능이 필요 없는 경우
4. **외부 의존성 최소화**: 환경설정, DB 등 외부 의존성 없이 어디서든 동일하게 동작

---

## 6. Service 생성자 인자 관리와 @InjectMocks

- **@InjectMocks 사용 시 장점**
  - 생성자 인자 관리 자동화
  - 테스트 코드의 가독성/유지보수성 향상
  - 생성자/필드/Setter 주입 모두 지원
  - 테스트 코드의 견고함
  - Mockito의 다양한 기능과 연계

- **직접 생성자 호출 시 장점**
  - 불필요한 프레임워크 의존성 제거
  - 테스트 속도 향상
  - 테스트의 독립성/단순성
  - 동시성/상태 검증에 유리
  - 실제 운영 코드와 거의 동일한 환경

- **@InjectMocks 사용 시 단점**
  - 테스트의 명시성/직관성 저하
  - 생성자/필드/Setter 주입 혼용 시 혼란
  - 리팩토링 시 테스트 깨짐
  - 디버깅/문제 추적 어려움
  - 외부 프레임워크 의존성
  - 테스트 코드의 은닉성

---

## 7. Mock 객체와 실제 객체 사용 기준

| 상황/목적                       | Mock 객체 사용 | 실제 객체 사용 |
|----------------------------------|:-------------:|:-------------:|
| 외부 의존성 대체                 | O             | X             |
| 비즈니스 로직만 검증             | O             | X             |
| 예외/특수 상황 시뮬레이션        | O             | X             |
| 테스트 속도 중요                 | O             | △             |
| 부작용 방지                      | O             | X             |
| 통합/플로우/상태/동시성 검증     | X             | O             |
| 실제 연동 검증                   | X             | O             |
| 운영 환경과 유사한 테스트        | X             | O             |
| 단순 객체/메모리 Table           | △             | O             |

- **단위 테스트**: Mock 객체 적극 활용 (Service, Controller 등)
- **통합/시스템 테스트**: 실제 객체(실구현체) 사용

---

## 8. UserPointService vs Controller 통합테스트에서 SpringBootTest 사용 여부

| 테스트 대상         | SpringBootTest 사용 | 목적/이유                                    |
|--------------------|:------------------:|----------------------------------------------|
| Service 통합테스트  | X                  | 순수 자바 객체로 비즈니스 로직, 동시성 검증   |
| Controller 통합테스트 | O                 | 실제 HTTP API, Spring 환경, 전체 플로우 검증 |

- **Service 테스트**: 빠르고 가볍게, 순수 자바 객체로만 검증
- **Controller 테스트**: 실제 API 환경과 최대한 유사하게, Spring 컨텍스트를 띄워서 검증

---

이 문서는 HashMap vs ConcurrentHashMap의 동작 및 테스트 환경에서의 DI 방식, Mock 객체와 실제 객체 사용 기준, 그리고 통합테스트 설계 원칙을 체계적으로 정리한 자료입니다.
